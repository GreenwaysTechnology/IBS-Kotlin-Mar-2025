				Koltlin
..............................................................................................
What is Kotlin?
    Kotlin is the programming language for JVM.

JVM is runtime to run java applications.

JVM is abstract computer which solves the problem of platform independant.

One source and one Compiled code can be ported  on multiple platforms(os/hardware)

What is java?
  You mean java is programming language but not.
Java is technology, technolgy means solves the pratical problems.

Java technology means many things

1.Java programming language
2.tools
   compilers,debuggers,libs,apis....
3.runtime - jre
    -JDK


Java Programming language offers the source code , compiler compiles the source code into object code(byte code).

How java technology works? who controls java technology?

JCP - java community process who standarize the java technology.

All java versions and enchancments certified by JCP only...

JCP classifies java into there major editions

1.JAVA SE
2.JAVA EE
3.JAVA ME

JEP - This is committe formed by oracle
.....................................................................................
			JSR 223 :Scripting for The Java  Platform
....................................................................................
JSR 223 spec was released on June-10-2003

Before this specification, only one programming language was there for JVM- Java Programming language.

The spec aim is to introduce new languages for JVM - Poly glot languages for Java Platform.

Based on this spec, the first language other than java pl, was created  for JVM-Groovy Programming langugage.

.....................................................................................
			    JSR 223 Poly glot language implementation


        java pl    Groovy   Scala  Kotlin Clojure XX
         -------------------------------------------
			 |
		      byte code
                         |
                        jvm



The programs are developed using different styles.

Programming styles:

1.Object oriented
2.Functional programming
3.Procedural
4.Rule based 
etc....

Any language follows any of one of the style or multi style(style).
C is procedural language-single style language.
c++ is object oriented language-single style language

java was object oriented programming - single style

Java is object oriented,functional style programming languge- multi style.

Kotlin is object oriented, functional style programming language...

Language is classified based on types(data types)
.................................................

1.strongly typed /static typed
   The type of variable is decided during compile time.
   int a=10;
   a="hello"
2.weak typed/dynamic typed
  The type of variable is decided during runtime time.
  var a =10
  a ="hello"

             Kotlin is dynamic(type inference) and strongly typed language.
			var a=10
			a="hello"
...................................................................................

Programming language
 =>GPL - General Purpose programming language
     language used to build any type of apps
 =>DSL -  Domain specific language
     language used to build sepcific types of apps- html,css

kotlin helps to build dsl code...

DSL code is more declarative 
 
  move left and move right - dsl code
  find sqrt of 10 - dsl code
  take 1 pile every day at morning 7 am  

....................................................................................

Programming methodlogy

1.imperative programming
    => any program there is two aspects
        ->infra code
        ->application logic
    what is it? and how is it?

2.declarative programming
   focus only application logic
   more readable
   less boilerplate 
   less code maintaince because less code
  eg:
    list.sort.filter.map.find.flaten

                Kotlin is more declarative programming  language
.....................................................................................
	 "Kotlin helps to build more declarative, dsl , functional,object oriented          apps"


Kotlin language is highly multi purpose programming language:

 - To build mobile apps -> multi platform mobile - android and ios apps.
 - To build server side apps - microservices,RESTFull apis,dynamic web apps..
 - To build platform native apps like c++...


Learning Path:
1.language fundamentals
2.object oriented programming
3.functional programming
4.Exception handling
5.Data structures
6.Concurrency - Co-routines
7.Async programming / Non Blocking apps
8.How to build DSL

....................................................................................
				Language fundamentals
.....................................................................................

We are going to build console based Kotlin apps.

software req:
1.JDK
2.Intellij idea -  IDE 

Step to create Kotlin project.

You can use any build system to create kotlin project
Maven or Gradle.

Every Kotlin program is saved With "FileName.kt".

Unlike java kotlin programs need not be started with classes, you can start with main method(function).

Kotlin Programming style:

1.file based/script based
2.class based - oo style

How to declare functions in kotlin?

 fun functionName(arg){
   //function body...
 }
Every kotlin program begins with "main" function...
	
in java : System.out.println()

In Kotlin ; is optional

HelloWorld.kt

fun main(){
    println("Hello Kotlin")
}

Steps:
1.project creation.
2.write helloworld


HelloWorld.kt

package com.ibs.kotlin.basics

fun main(){
    println("Hello Kotlin!")
}
....................................................................................

....................................................................................

Language Fundamentals:

1.Comments
  Single line comment
	//
  Mutli line comment
	/**
        /**
/**
 * Every Kotlin program starts with main function.
 * In Kotlin ; optional
 */
fun main(){
    //which prints Hello message
    println("Hello Kotlin")
}
..
....................................................................................
			    Data types 
.....................................................................................

Program means collection of instructions.

instrcutions -(information + how the information is stored,processed,reterived)
information is nothing but data.

How to store data inside computer using programs?

we need to store in memory address, in order to store we need handle

variable: it is handle to store data.

Data:
 -simple data - atomic data - primtive data
  eg:10 -
any data can be broken into smaller unit.

Numbers:
   1.whole number
       -binary,oct,hexa
   2.decimal numbers
      - float


Abstract data types:
   In the begining of programming only basic were used by languages like numbers,characters.
   How to create our own type system- Type of data - Custom Types...

struct,union - c implemnetation of abstract types

Any abstract types are built on the top of built in types.
 
 struct Employee = {numbers,characters}

After some time new type creation syntax introduced "class"

 class Employee {
    numbers
    characters
 }
...................................................................................

Type - Data type
 -primtives
 -Complex type/Custom Type/Reference Type

Variable
 -Holder to hold any type 
Literal
 -Values(Primitives,Complex values)


In kotlin types are dervied from java language.

Java Primtive Types:
1.numbers
 -byte,short,int,long
 -float,double
2.char
3.boolean

In Kotlin you cant use primtives type directly... rather you have to use always "Complex type" - Reference Type - Wrappers Types.

In Kotlin , every thing is Object.

variables are introduced using keywords

-var
-val

variable declaration:
 
 var | val | withoutanyKeyword variableName:Type = literal

package com.ibs.kotlin.basics.types

fun main() {
    var speed = 100
    println(speed)
  //  speed = true
    var a = 1
    var s = 12
    var b = 10
    var l = 19999
    var f = 10.3f
    var d = 90.334
    var isActive = true
    println("Int " + a)
    println("Short " + s.toShort())
    println("Byte " + b.toByte())
    println("Long " + l.toLong())
    println("Float " + f.toFloat())
    println("Double " + d)
    println("Boolean " + isActive)
}

.....................................................................................
			 Static Typed language or Dynamic typed Language

Static type:
int a =10;
a=90; // it is valid
a=true //it is invalid - compile time error

Dynamic typed:

in Js
 let a =10;
 a =100 //valid
 a=true //valid
In groovy
 def a =10
  a=10 //valid
  a=true //valid


Kotlin language is "strongly typed/Static typed" language, even though language looks like without type, but the type is infered
fun main(){
    var a =10
    println("A " + a )
    a=90
    println("A " + a )
    //a=true // invalid
    println("A " + a )

}
Strings :
 String is collection of unicode characters
 String Object 
 Strings are declared  with "" , """

Strings are concated with  + -> traditonal style

Strings are represented with "String Templates" - String interploation.

 "$variable" / "${}"



package com.ibs.kotlin.basics.types

fun main() {
    var firstName:String = "Subramanian"
    var lastName = "Murugan"
    //java style ; not recommened
    println("Name " + firstName + lastName)
    //kotlin style: recommended
    println("Name $firstName ${lastName}")

}
...........................................................................................
                          Multi Line
..........................................................................................
package com.ibs.kotlin.basics.types

fun main() {
    //traditional style: java style
    var doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body>" +
            "</body>" +
            "</html>"
    println(doc)
    var message = "How are you"
    var newDoc ="""
         <html>
         <head>
         <title>Home</title>
         </head>
         <body>
         <h1>${message}</h1>
         </body>
        </body>
        
    """.trimIndent()
    println(newDoc)
}

...................................................................................
			 var vs val(final)
...................................................................................



package com.ibs.kotlin.basics.types

fun main() {
    var i = 100
    println("I $i")
    i = 200
    println("I $i")

    val j =100
    println("J $j")
    //j=2323

}

var with variable can be reinitalized, where as val cant be reinitalized.
.....................................*****************.............................
...................................................................................
				Operators
....................................................................................
All operators supported by java  , supported by kotlin as well.

Types of operators
1.arithmetic operators
2.conditional operators
3.logical operators




package com.ibs.kotlin.basics.operators

fun main() {
    var a = 10;
    var b = 22;
    var c = a + b
    println("Add $c")
    c = a - b
    println("Substraction $c")
    c = a * b
    println("Multiplication $c")
    c = a / b
    println("Division $c")
    c = a % b
    println("Moduls $c")
    //augmentd operators
    var counter = 0
    counter += 1
    println("counter $counter")

    //logical operators : based on boolean expressions
    var isValid = true
    var isEnabled = false
    var res = isValid && isEnabled
    println("Result $res")

    //Equals : Structural equals
    var x = 100
    var y = 100
    var isEqual = x == y
    println("X AND  Y ARE Equal $isEqual")
    var str = "hello"
    var str1 = str
    println("str AND  str1 ARE Equal ${str1 == str}")

    //comparasional operators
    var isBig  = a > b
    println("IsBIg $isBig")
}

.....................................................................................
			 conditional work flow
.....................................................................................
conditions: - if

In kotlin, "if" is an expression like (a+b,return 100),In java if is statement
it can return a value like functions.
so in kotlin there is no need for tenary operator.
(condtion ? truthy:falsy)- similar construct if expression provides

package com.ibs.kotlin.basics.conditionals

fun main() {
    var a = 1000
    var b = 2000
    var max = a
    //traditional style: java style
    if (a < b) {
        max = b
    }
    println("Max $max")
    //Kotlin expression style
    if (a < b) max = b
    println("Max $max")
    //if..else : java style
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if..else kotlin style
    max = if (a > b) a else b

    var isValid = false
    var response = if (isValid) {
        //any code to be executed
        println("More code")
        var firstName = "Subramanian"
        //return value
        "Hello $firstName"
    } else {
        println("More code")
        var firstName = "Murugan"
        //return value
        "How are you Mr.$firstName"
    }
    println(response)


}

When expression:
...............
 When is similar to if expression, but when defines a condtions with multiple branches. which is similar to switch statement...
In Kotlin no switch case...

Simple When:

package com.ibs.kotlin.basics.conditionals

fun main() {
    var x = 1
    when (x) {
        1 -> println("X is One")
        2 -> println("X is Two")
        else -> println("No match Found")
    }
}

Either this or that:
....................
package com.ibs.kotlin.basics.conditionals

fun main() {
    var x = 0
    when (x) {
        0, 10 -> println("X value is either 0 or 10")
        else -> println("No match Found")
    }
}

Range:
.........
package com.ibs.kotlin.basics.conditionals


fun main() {
    var input= 5666
    when (input) {
       in 1..107-> println("Input Range is 1 to 100")
       !in 1..100 -> println("Input Range doest not match ")
    }
}

Return Result from the when expression:
.......................................


package com.ibs.kotlin.basics.conditionals

fun main() {
    var isLoggedIn = true
    var status =  when(isLoggedIn) {
        true -> "LoggedIn"
        false -> "LoggedOut"
    }
    println("Status $status")

}

if when expression arg is not supplied, the branch conditions are simply boolean expression, and a branch is executed when its condition is true.

package com.ibs.kotlin.basics.conditionals

fun main() {
    var num = 1;
    var isEvenOrOdd = when {
        num % 2 == 0 -> "Even"
        num % 2 != 0 -> "Odd"
        else -> "No Match Found"
    }
    println("$num is $isEvenOrOdd")
}

....................................................................................
				Loops
...................................................................................
Loops:
 for
 range
 while
 do...while

package com.ibs.kotlin.basics.loops

fun main() {
    //RANGE
    for (count in 1..10) {
        println("Count $count")
    }
    //reverse order
    for (count in 5 downTo 1) {
        println("Count $count")
    }
    //step by
    for (count in 1..10 step 2) {
        println("Count $count")
    }
    //until
    for (count in 5 until 10) println("Count Until $count")

    //while loop
    var x = 1
    while (true) {
        println("while value $x")
        x++
        if (x > 5) break
    }
}
.....................................................................................
				Functions
.....................................................................................

What is function?
  The term function is derived from the mathmetics.
  The function represents unit of execution
  The function is building block of computer system itself.

Types of functions?

1.passive functions
2.active functions

Every program is running on another program called runtime/Process

aJava programs are running on the another program called JVM.
J
VM is written in c language.

JVM is just process just like other process running on operating system.

Every Process has its own arch...

Process has three seg.

1.heap
2.Stack 
3.Program data

Program data/method area
........................
  All passive instructions are stored.
  Passive instructions means that instructions are not used by CPU and Main memory.

All functions declrations are stored inside this area
All Static variables are stored inside this area
All literals(values) are stored inside this area

....................................................................................
			 Runtime Represention of functions
...................................................................................

In Programs, runtime representation means, which should be accessed by CPU,Memory should be allocated inside main memory.

Every functions must be allocated on RAM, so that it can be accessed by CPU.

//declaration

function main(){ 

}

main()---> we have to allocate memory on RAM--->

When function is called, the function is pushed into stack.

Stack is just first in last out data structure.

Once the function gets pushed into stack, The process allocates memory.

This memory is called as "Stack Frame"

After execution of statck frame it is removed from memory, so that other stack frames will start 

sayHello----frame is created---frame is running---frame is removed
sayHai -----frame is created ---frame is runnin-frame is removed

.....................................................................................
			  Kotlin functions
....................................................................................

Kotlin supports different functions

1.normal functions/Standard functions
2.infix function
3.local function
4.member function
5.Tail Recursive function
6.inline function
7.suspend function
8.operator function
9.lambda functions
10.Single Expression function



1.Normal functions/Standard functions

 -how to declare function
 -how to invoke 
 -args and parameters
   -Named,optional args
 -return types  and values



package com.ibs.kotlin.functions

//function declaration
fun sayHello() {
    println("Hello")
}

fun add(){
    println("Add Function")
    var a =10
    var b =20
    var c = a + b
    println("c $c")
}
fun main() {
   //function invocation
    sayHello()
    add()
}

			 Function args and parameters
...................................................................................

What is arg?
 Arg is place holder which holds values
What is parameter?
 Parameter is nothing but value what we pass.
package com.ibs.kotlin.functions.args

fun sayHello(name: String) {
    println("Hello $name")
}

fun add(a: Int, b: Int) {
    var c = a + b
    println("Result is $c")
}

fun main() {
    sayHello("Subramanian")
    add(10, 10)
}
Default Args:
  In java parameters must be passed for given args,
  In Kotlin you can skip parameters, we can provide default args

package com.ibs.kotlin.functions.args

fun sayHello(name: String = "") {
    println("Hello $name")
}

fun add(a: Int = 0, b: Int = 0) {
    var c = a + b
    println("Result is $c")
}

fun main() {
    sayHello("Subramanian")
    add(10, 10)
    //without any parameter
    add()
    add(a = 10, b = 20)
    add(b = 90, a = 89)
}

...................................................................................
			Positional and Named Parameters
....................................................................................

In java parameters are position based

void add(int a,int b){

}
add(10,10)
void format(String str,boolean b,int a){

}
format("sss",true,10)

Kotlin also supports positions based.

eg
fun add(a: Int = 0, b: Int = 0) {
    var c = a + b
    println("a $a b $b c $c")
}

fun main() {
    add()
    add(10,20)
}
..................................................................................
			 Named Parameters
...................................................................................
You can pass values in any order.
Named args also can have default values.
You can skip values any where in the arg list.


fun format(str: String = "str", normalizeCast: Boolean = false, upperCaseFirstLetter: Char = 'A') {
    println("Str $str noralizeCase ${normalizeCast} UpperCaseFirstLetter ${upperCaseFirstLetter}")
}

fun main() {
    format();
    //named parameters
    format(str = "Hello", upperCaseFirstLetter = 'B', normalizeCast = true)
    format(normalizeCast = false);
}


Positional and Named Parameters

1.function does not have default values -  Optional parameter
2.function with default value- Named parameter
..............................................................................................
				 Any Type and Functional Arg
..............................................................................................

In java "java.lang.Object"  can take any type of object

void accept(Object a){

}

accept("Hello")
accept(1100)
accept(new Date())
accept(new Employee())

In Kotlin instead of Object we have Super Object is "Any"

     "The root of the Kotlin class hierarchy. Every Kotlin class has Any as a superclass"


package com.ibs.kotlin.functions.args

fun accept(a: Any) {
    println(a)
}

fun main() {
    accept("Hello")
    accept(100)
    accept(39.34)
    accept(true)
}
....................................................................................
			 Return values and Type
....................................................................................

In Kotlin function returns any object if function does return any thing which is Called "Unit".

The "Unit" is type with only One Value- Unit

package com.ibs.kotlin.functions.returns

//exclit Unit
fun doStuff(): Unit {
    println("Hello")
    return
}
//implicit Unit
fun doSomething() {
    println("Unit")
    return
}

fun main() {
    doStuff()
    doSomething()
}

Other Types:
package com.ibs.kotlin.functions.returns

fun sayHello(name: String = "Ram"): String {
    return "Hello $name"
}

fun multiply(a: Int = 0, b: Int = 0): Int {
    return a * b
}

fun main() {
    var res = sayHello("Subramanian")
    println(res)
    println(multiply(b = 90, a = 80))
}
....................................................................................
....................................................................................
			 Single-Expression functions
....................................................................................
When a function returns a "single Expression" no more body, the curly braces and return statement can be omitted and body can be specified after = symbol
return type can be ommitted, which is typeinferenced 

package com.ibs.kotlin.functions.singleexpression

//normal syntax
//fun sum(a: Int = 0, b: Int = 0): Int {
//    return a * b
//}
//single Expression Function
//fun sum(a: Int = 0, b: Int = 0): Int = a * b
//Omit the return type
fun sum(a: Int = 0, b: Int = 0) = a * b
fun display(name: String = "") = "Hello $name"

fun main() {
    println(sum(10, 10))
    println(display("Subramanian"))
}
..............................................................................................
....................................................................................
			 Variable args-Var args
...................................................................................

In order to receive variable args, kotlin provides a keyword "vararg".
package com.ibs.kotlin.functions.varargs

fun logger(vararg args: String) {
    for (arg in args) println(arg)
}

fun main() {
    logger("Employee.kt", "Warning", "Save Method is called")
    logger("Employee.kt", "Error", "remove Method is called", "501")
}

.....................................................................................
			null
.....................................................................................

What is null?
  
int a =10; 
String str =null



10 is value (literal)
null ? value ----> it is value

Different languages implement null differently.

In java null is Object. NULL object.

NULL Object means , you dont have valid Object of that Type.

if you access any property on Null Object , It will throw error- NullPointerException.


if NullPointer Exception occurs, the system crashes.

Handling null in java like language is really challanging....
...................................................................................
			How to handle  Null in Kotlin
...................................................................................
Null reference/Object is unavoidable in any object oriented systems, handling null is more chaallange.

How to handle null very safely?

  Kotlin like languages now a days handles null very efficiently without crashing system.
  Kotlin handles null positiviely, if there is null, we can give alternate values.

In java , the methods,properties access are verfied during run time only.
String str =null
str.trim() 

In java , null is verified during runtime.
................

In Kotlin "null" is verified during compile time itself, so that your code will be more strong and safe during development and production

App never crashes because of null errors.
....................................................................................
....................................................................................
			 Kotlin and null
.....................................................................................

1.Kotlin never allows null by default.

package com.ibs.kotlin.nulls


fun main() {
    var name:String = null 
}
The code causes compile time error
 "Null can not be a value of a non-null type String"
  
package com.ibs.kotlin.nulls


fun main() {
    //var name:String = null
    var name: String
    println(name)
}
The code also causes compile error.
 because when declaration of variable , no error, but when access the variable ,it will give you error.

As of now the variable must have been initialized to some string.

What if i want null to be initalized to a variable. How to declare null in kotlin?

What if i want "nullable" value?

"nullable" means the variable can have null.

var variableName:Type? = null

package com.ibs.kotlin.nulls


fun main() {
    //var name:String = null
    var name: String? = null
    println(name)
}
....................................................................................
			What if i access any property on null
....................................................................................
package com.ibs.kotlin.nulls


fun main() {
    var name:String? = null 
    println(name.length)
}
this code causes compile time error, you cant access any property on null reference.


Way 1: Handling null using java style

package com.ibs.kotlin.nulls


fun main() {
    var name: String? = null
    //Ways to handle null
    //Way 1: Handling null using java style
    if (name != null) {
        println(name.length)
    }
}

Way 2: Kotlin style "Using safe navigation operator"

variable?.property
  here if variable has null , then output would be "null" string representation.

package com.ibs.kotlin.nulls


fun main() {
    var name: String? = null
    //Ways to handle null
    //Way 1: Handling null using java style
    if (name != null) {
        println(name.length)
    }

    //Way 2: Kotlin style "Using safe navigation operator
    println(name?.length)
}

Way 3: Kotlin style "Using Elvis Operator" : if there is null,if you want some default  instead of "null" string.


package com.ibs.kotlin.nulls


fun main() {
    var name: String? = null
       //Way 3: Kotlin style "Using Elvis Operator" : if there is null,if you want some default
    // instead of "null" string.
     var length = name?.length ?: 0
    println("String length is $length")
}

way 4: kotlin style: for some reasons,"if you want Runtime Exception" How to throw NullPointerException !! assertion operator which throws runtime exception.


package com.ibs.kotlin.nulls
o

fun main() {
    var name: String? = null
    //way 4: kotlin style: for some reasons,"if you want Runtime Exception" How to        //throw NullPointerException
    //!! assertion operator which throws runtime exception.
    println("${name!!.length}")
}

.....................................................................................
			Functions and Nullable values
...................................................................................

package com.ibs.kotlin.nulls

fun sayHello(name: String?="") {
    println("Hello ${name?.toString() ?: ""} and its length is ${name?.length ?: 0}")
}

fun main() {
    sayHello("Subramanian")
    sayHello(null)
}
.....................................................................................
			  Functional Programming
.....................................................................................

What is functional Programming?
  Functional programming is one of the programming style to build apps...

Programming Principles:
1.Procedural programming - c
2.Object oriented programming - c++,java,C#....
3.functional programming.

Functional programming principles and patterns implemented from the mathmetics called  "Lambda calculus".

Lambda calculus (also written as Î»-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.
 It is a universal model of computation that can be used to simulate any Turing machine. 

"The word function derived from calculus"

According to calculus function means which accept as input, and return result.

calculus talks about how to build "Abstract Computer"

calculus was introduced by matmetician called "Alonzo Chruch in the 1930".

Based on calculs , the first programming language was created called "LISP"

Lisp, an acronym for list processing, is a functional programming language that was designed for easy manipulation of data strings. As one of the oldest programming languages still in use, Lisp offers several different dialects and has influenced the development of other languages.

Lambda Calculs implementation languages:
........................................
1.Lisp
2.CommonLisp
3.Clojure - Lisp for JVM
4.Haskell
5.Scheme
6.Javascript
7.JVM languages
   - java 8 on wards
   - Groovy
   - Scala
   - Kotlin 
   - Clojure

Functional Programming principles(calculus Basic):
..................................................

1.Functions are first class Citizens
2.Referetial transparency
3.Pure functions
   Side effects, immutablity
4.Recurrsive functions rather than loops.

....................................................................................
			 Purely functional and functional style
....................................................................................

Purely functional programming language means, the language implements 100% all fp principles
Functional style programming language means, partitial principles are implemented.

"Kotlin is functional style language".

Kotlin functional programming implementations:
...............................................

1.Functions are first class Citizens

 What is first class citizen?
	
  Functions are passed around(in ,out)

This means the language supports passing function as parameter to another function,returing them as values from another function, and assigning them to variables or storing them in data structure.

"functions are literal , means that functions are value like int,double,String"

var a=10
 here a is variable
 here 10 is value(literal)

in kotlin functions are treated like 10

var myTask = fun delay(){}

Higher order functions:
.......................
	First class functions are necessity for the functional programming style, in which the use of higher order functions is standard practice.

According to calculus mathmetics, higher order function is a function that does the following things

1.Takes one or more function as arg
2.Returns a function as its result.

Can i say the below fun is higher order function or not?

fun map(){

}
No , Because it does not follow the thumb rule of hof.
.....................................................................................
			Since Kotlin Static Typed language, we need to tell the 
				"Type of function Itself"
....................................................................................

fun map(variableName:FunctionType){

}
In Kotlin, every thing is object, FunctionType itself is object behind the scene.
....................................................................................
			  Kotlin Function Type syntax
....................................................................................

Note: T means Type

1.(T)->T
 eg:
  (Int)->Int
  (Int)->String

2.(T1,T2)-T3
  (Int,Int)->Int
  (String,Int)->String

3.(T)->Unit
  (Int)->Unit
  ()->Unit

fun map((T)->T){

}

Rules:
 1.All function tyes must have a parenthesized types list and return type
 2.Function type can be optinally have an additional receiver type, which is represented in "." notation

  "ReceiverType".(B,C)->D
eg:
   A.(B,C)->D

A - Receiver Object
B,C -args
D-Return type

3.Incase of async code,

suspend A.(B,C)->D
suspend (B,C)->D

Nullable and function args:

((A,B)->C)?
(a.(B,C)->D)?
.....................................................................................

Function Literals:
...................

 As we dicussed already functions are literals/values, can be stored into a variable.

 Since function stored inside variable, that variable can be used to invoke that function.


Storing function into a variable (function as literal)

var a:Int =10

here a is variable, Int is type, 10 is value (literal),var is keyword
in the similar way we assign function to a variable.


var sayHello: () -> Unit = fun() {
    println("Hello fun")
}

here sayHello is just variable
: is separator
()-> Unit is "Function Type like String"
fun(){} - Value /literal - function literal

package com.ibs.kotlin.fpprinciples

//declare variable with expclit type
var hello: String = "hello"

//function declaration with explcit type
var sayHello: () -> Unit = fun() {
    println("Hello fun")
}

fun main() {
    println(hello)
    sayHello()
}

With Type inference
..................
package com.ibs.kotlin.fpprinciples

//declare variable with expclit type
var hello: String = "hello"
//declare variable with implicit type ; type inference
var firstName ="Subramanian"

//function declaration with explcit type
var sayHello: () -> Unit = fun() {
    println("Hello fun")
}
//function declaration with implcit type : type inference
var sayHai = fun() {
    println("hai")
}


fun main() {
    println(hello)
    sayHello()
    sayHai()
}

Anonymous function:
..................
 Function without name.
 fun() {
    println("hai")
}


functions without type annotation: type inference:

package com.ibs.kotlin.fpprinciples


//Function with type inference
var greet = fun() {
    println("Greet")
}

fun main() {
    greet()
}

Anonymous Function with Parameters:


package com.ibs.kotlin.fpprinciples


//With type
//var add: (Int, Int) -> Int = fun(a: Int, b: Int): Int {
//    return a + b
//}
//without Type
//var add = fun(a: Int, b: Int):Int {
//    return a + b
//}
//Single function expression with anonymous function
var add = fun(a: Int, b: Int) = a + b

fun main() {
    println(add(10, 3));
}

Nullable parameters and Anonymous function:
.............................................
//With type
//var add: (Int, Int) -> Int = fun(a: Int, b: Int): Int {
//    return a + b
//}
//without Type
//var add = fun(a: Int, b: Int):Int {
//    return a + b
//}
//Single function expression with anonymous function
var add = fun(a: Int, b: Int) = a + b

fun main() {
    println(add(10, 3));
}

Nullable parameters and Anonymous function:
.............................................
package com.wipro.kotlin.functionalprogramming

//var accept: (String?) -> String? = fun(message: String?): String? {
//    return message
//}
//var accept = fun(message: String?): String? {
//    return message
//}
var accept: ((String) -> String)? = fun(message: String): String {
    return "Hello $message"
}
var display = fun(message: String?): String? {
    return "Hello $message"
}

fun main() {
    //println(accept("Hello"));
    accept?.invoke("Hello")
    display?.invoke("Hello");
    display?.invoke(null)
}
.......................................................................................
			 Higher order functions
/////////////////////////////////////////////////////////////////////////////////////

		
Function is passed as parameter to another function.

Before understanding higher order function, we need to understand, how parameters are passed.


package com.ibs.kotlin.fpprinciples.hof


fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
    //How to pass values to the function?
    //hard coded value
    println(add(10, 10))
    //via variables
    var x = 10
    var y = 20
    println(add(x,y))
}

Simple Higher order function:


package com.ibs.kotlin.fpprinciples.hof

//hof : function as parameter to another function
fun sayGreet(action: () -> Unit) {
    //invoke that function
    action()
    action.invoke()
}

fun main() {
//    var myFun = fun() {
//        println("Hello")
//    }
    var myFun: () -> Unit = fun() {
        println("Hello")
    }
    sayGreet(myFun)
    //passing function directly
    sayGreet(fun() {
        println("Hello , How are you")
    })
}
Higher orders with args and paramters:
.....................................
package com.ibs.kotlin.fpprinciples.hof

fun adder(action: (Int, Int) -> Unit) {
    action(10, 10)
}

fun main() {
    adder(fun(a: Int, b: Int): Unit {
        var c = a + b
        println(c)
    })
}
Named Parameters with Higher order function:
............................................
package com.ibs.kotlin.fpprinciples.hof

fun login(userName: String = "foo", password: String = "bar", resolve: (String) -> Unit, reject: (String) -> Unit) {
    if (userName == "admin" && password == "admin")
        resolve("Login success")
    else
        reject("Login failed")
}

fun main() {
    login(
        userName = "admin",
        password = "admin",
        resolve = fun(status) { println(status) },
        reject = fun(err) { println(err) }
    )

    login(
        resolve = fun(status) { println(status) },
        password = "admin",
        reject = fun(err) { println(err) },
        userName = "admin"
    )


}
.............................................................................................

....................................................................................
		    			Lambdas
....................................................................................

What is Lambda?
 The term Lambda is derived from Lambda calculs.

Lambdas are function literals only, can be assigned to a variable, passed around(in and around).

How to declare Lambda expression?

var or val variableName:FunctionType = {arg->functionbody}

Rules:
1.A lambda expression is always surroned by {}
2. Parameter declarations in the full synatatic form go inside curly braces and have optional type annotations.
4.The body of the function will go after "->"
5.The infered return type is not "Unit" by default, the last line (possibly) expression inside the lambda body is treated as the return value.
6.Lambda can be passed to another function as parameter or Lambdas can be passed to another lambda as parameter.

Simple Lambda
package com.ibs.kotlin.fpprinciples.lambdas

//formal function
fun add(a: Int = 0, b: Int = 0): Int {
    return a + b
}

//single function expression
fun addExpression(a: Int = 0, b: Int = 0) = a + b

//function as literal : default values can't be initialized in the function literal
var addFunLiteral = fun(a: Int, b: Int): Int {
    return a + b
}

//lambdas
var addLambda = { a: Int, b: Int ->
    //body of the function
    println("lambda example")
    // return  a +b invalid
    a + b //last line of the function to be treated as return value and also type is infered
}

fun main() {
    println(add())
    println(addExpression())
    println(addFunLiteral(33, 333))
    println(addLambda(1, 2))
}

.....................................................................................
			Lambda Complex syntax
.....................................................................................

package com.ibs.kotlin.fpprinciples.lambdas

var login = { userName: String, password: String ->
    if (userName == "admin" && password == "admin")
        "Login Success"
    else
        "Login Failed"
}

fun main() {
    println(login("admin", "admin"))
}
..................................................................................
		Lambda with Single Paramter - it variable
...................................................................................
"it" is implicit variable can be used in lambda to replace single explicit args
s

package com.ibs.kotlin.fpprinciples.lambdas

//var sayMyName = { name:String ->
//    "Hello ${name}"
//}
var sayMyName: (String) -> String = {
    println("Hello")
    print("how are you")
    "Hello ${it}"
}
var doubleIt: (Int) -> Int = { it * 2 }


fun main() {
    println(sayMyName("Subramanian"))
    println(doubleIt(10))
}

...................................................................................
			Higher order functions and Lambda
...................................................................................
How to pass lambda as parameter to another function or another lambda?

package com.ibs.kotlin.fpprinciples.lambdas

fun delay(action: () -> Unit) {
    action.invoke()
}

fun main() {
    //passing regular function as parameter
    delay(fun() {
        println("Hello")
    })
    //passing lamabd
    var task = {
        println("Hello task")
    }
    delay(task)
    //passing lambda directly to the function
    delay({
        println("Hello how are you task")
    })
}


.....................................................................................
How lambda can accept another lambda as parameter?


package com.ibs.kotlin.fpprinciples.lambdas

var async = { action: () -> Unit ->
    action()
}

fun main() {
    var task = {
        println("task-lambda")
    }
    async(task)
    async({
        println("lambda task 1")
    })
    async(fun() {
        println("delay")
    })

}

.....................................................................................
		 Higher order function takes more parameters(mixed)

package com.ibs.kotlin.fpprinciples.lambdas.dsl

fun compute(no: Int = 0, action: () -> Unit) {
    println("No $no")
    action()
}

fun main() {
    compute(10, { println("compute") })
    compute {
        println("hello")
    }
}
.............................................................................................
DSL syntax for more parameters:
...............................
When you pass lambda as second or last parameter, the first parameter can be enclosed with "()" and second parameter passed passed directly.

Note: lambda should be always last parameter.


package com.ibs.kotlin.fpprinciples.lambdas.dsl

import kotlin.concurrent.thread

fun compute(no: Int = 0, action: () -> Unit) {
    println("No $no")
    action()
}

fun filterBy(
    order: String = "asc",
    name: String = "name",
    no: Int = 0,
    action: () -> Unit
) {
    println("Order $order Name $name No $no")
    action()
}

fun main() {
    compute(10, { println("compute") })
    //dsl syntax
    compute(23) { println("compute") }
    //dsl syntax with default value
    compute { println("compute") }

    filterBy { println("Filter callback") }
    filterBy(name = "Subramanian", order = "asy", no = 1) {
        println("Filter callback with values")
    }
    //Thread creation using lambda
    thread(start = true, name = "MyThread1", priority = 2) {
        Thread.sleep(2333)

        println("${Thread.currentThread().name}")
    }

    thread(start = true, name = "MyThread2", priority = 1) {
        println("${Thread.currentThread().name}")
    }

    thread(start = true, name = "MyThread3", priority = 2) {
        println("${Thread.currentThread().name}")
    }
}
....................................................................................
			_ notation in lambda
...................................................................................


package com.ibs.kotlin.fpprinciples.lambdas.dsl

//if you want to skip some parameters/args we can use _
fun doCompute(a: Int = 0, b: Int = 0, action: (Int, Int) -> Unit) {
    action(a, b)
}

fun main() {
    doCompute(b = 233) { _, b -> println(b) }
}

.....................................................................................
			 Object oriented programming in kotlin
.....................................................................................


How to declare classes in kotlin and how to create object?


package com.ibs.kotlin.oo

class Customer {
    //instance variables
    var id: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var status: Boolean = false
}

fun main() {
    //instance creation : no new keyword to create instance
    //customer is reference variable,Customer() is constructor call
    val customer = Customer()
    //access properties
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")
}
...................................................................................
			 State(data/properties) initalization
...................................................................................

1.inside class
2.outside class after object creation
3.during object creation- constructors

Inside Class:
package com.ibs.kotlin.oo

//class Customer {
//    //instance variables
//    var id: Int? = null
//    var firstName: String? = null
//    var lastName: String? = null
//    var status: Boolean = false
//}


class Customer {
    //instance variables
    var id: Int? = 0
    var firstName: String? = "Subramanian"
    var lastName: String? = "Murugan"
    var status: Boolean? = true

}

fun main() {
    //instance creation : no new keyword to create instance
    //customer is reference variable,Customer() is constructor call
    val customer = Customer()
    //access properties
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")
}

Outside class:
package com.ibs.kotlin.oo

//class Customer {
//    //instance variables
//    var id: Int? = null
//    var firstName: String? = null
//    var lastName: String? = null
//    var status: Boolean = false
//}


class Customer {
    //instance variables
    var id: Int? = 0
    var firstName: String? = "Subramanian"
    var lastName: String? = "Murugan"
    var status: Boolean? = true

}

fun main() {
    //instance creation : no new keyword to create instance
    //customer is reference variable,Customer() is constructor call
    val customer = Customer()
    customer.id = 1
    customer.firstName = "Geetha"
    customer.lastName = "Subramanian"
    customer.status = true
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")
}
....................................................................................
			 init block
...................................................................................

init is a special block used to initalize the variables and any code.

A Single class can have multiple init block but recommened having only one init block.

init blocks are getting executed the order in which it has been declared.

package com.ibs.kotlin.oo.stateinitblock

class Employee {
    //instance variables
    var id: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var status: Boolean? = null
    init {
        id = 1
        firstName = "foo"
        lastName = "bar"
        status = false
    }
    init {
        println("init 2")
    }
}
fun main() {
    //customer is reference variable
    //val customer: Customer = Customer()
    val employee = Employee()

    println("Id ${employee.id}")
    println("Name ${employee.firstName} ${employee.lastName}")
    println("Status ${employee.status}")

}
.....................................................................................
			Setter and getters
.....................................................................................

According to java bean spec, java needs to have setters and getters

According to kotlin setters and getters are implicit.

Can we use getters and setters in kotlin?

Yes!

Syntax:
  var <PropertyName>:[PropertyType] = [<property_initalizer>]
  getter
  setter
package com.ibs.kotlin.oo.settersgetters

class User {
    var name: String? = null
        set(value) {
            field = "Mr/Mrs $value"
        }
        get() = field?.uppercase()

}

fun main() {
    val user = User()
    user.name = "Subramanian"
    println(user.name)
}

